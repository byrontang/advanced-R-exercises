---
title: "OO Field Guide"
author: "Byron Tang"
date: "May 26, 2018"
output: html_document
---

```{r setup, include=FALSE}
library(pryr)
```

## S3

Note:

- S3 implements a style of OO programming called generic-function OO

- To determine if a function is an S3 generic, you can inspect its source code for a call to UseMethod()

- You can see all the methods that belong to a generic with methods()

- The underlying codes for the outputs (for unknown classes) of generic functions could be inspected in generic.defualt()

- Some S3 generics, like [, sum(), and cbind(), don't call UseMethod() because they are implemented in C. Instead, they call the C functions DispatchGroup() or DispatchOrEval(). Functions that do method dispatch in C code are called internal generics and are documented in ?"internal generic"

Additional Materials: https://www.cyclismo.org/tutorial/R/s3Classes.html

```{r}
cat("Generic mean:\n")
mean
cat("\nMethod mean.default:\n")
mean.default
cat("\nGeneric sum and cbind:\n")
sum
cbind
```


1. Read the source code for t() and t.test() and confirm that t.test() is an S3 generic and not an S3 method. What happens if you create an object with class test and call t() with it?

```{r}
cat("# generic t\n")
t
cat("\n# generic t.test\n")
stats::t.test
# In the source code of t.test, there's a line of code says UseMethod("t.test"),
# which means t.test() is an S3 generic and not an S3 method of t().

# In order to let generics t() to call a method for an object with class test,
# the naming of the method should be t.test, which is used for an existing function.
# As the result, after another t.test is created, when calling original t.test,
# it is neccessary to specify stats:: in order to call the function correctly.

t.test <- function(x) "A method"
cat("\n# Use method t.test\n")
t(structure(matrix(1:30, 5, 6), class = "test"))

cat("\n# Function t.test is overwritten\n")
tryCatch(t.test(1:10, y = c(7:20)), 
         error = function(e) e) # throws an error
cat("\n# Specify stats package to call function t.test\n")
stats::t.test(1:10, y = c(7:20)) # specify stats package is required.
```

2. What classes have a method for the Math group generic in base R? Read the source code. How do the methods work?

```{r}
cat("# data.frame, Date, difftime, factor, and POSIXt\n")
methods(Math)

cat("\n# Math() calls standardGeneric()
# standardGeneric dispatches the method defined for a generic function,
# using the actual arguments in the frame from which it is called.\n")
cat("\nGroup generic Math\n")
Math
```

3. R has two classes for representing date time data, POSIXct and POSIXlt, which both inherit from POSIXt. Which generics have different behaviours for the two classes? Which generics share the same behaviour?

```{r}
POSIXct_generics <- gsub(".POSIXct", "", as.vector(methods(class = "POSIXct")))
POSIXlt_generics <- gsub(".POSIXlt", "", as.vector(methods(class = "POSIXlt")))

cat("Different behaviours for the two classes: \n")
union(setdiff(POSIXct_generics, POSIXlt_generics), setdiff(POSIXlt_generics, POSIXct_generics))
cat("\nSame behaviours for the two classes: \n")
intersect(POSIXct_generics, POSIXlt_generics)
```

4. Which base generic has the greatest number of defined methods?

```{r}
ftype(cbind)
ftype(sum)
ftype(mean)
```


```{r}
# get all the base generics
objs <- mget(ls("package:base"), inherits = TRUE)
is_generic <- grepl("generic", sapply(objs, ftype))
# is_generic <- grepl("UseMethod", objs) # incomplete list, only includes S3 generic
funs_generic <- objs[is_generic]
S3_methods_list <- lapply(names(funs_generic), methods)
most_S3_methods <- funs_generic[sapply(S3_methods_list, length) == max(sapply(S3_methods_list, length))]
cat("S3 generic with most methods: \n")
names(most_S3_methods)
cat("\nNumber of methods: \n")
length(methods(names(most_S3_methods)))
```

5. UseMethod() calls methods in a special way. Predict what the following code will return, then run it and read the help for UseMethod() to figure out what's going on. Write down the rules in the simplest form possible.

y <- 1
g <- function(x) {
  y <- 2
  UseMethod("g")
}
g.numeric <- function(x) y
g(10)

h <- function(x) {
  x <- 10
  UseMethod("h")
}
h.character <- function(x) paste("char", x)
h.numeric <- function(x) paste("num", x)

h("a")

```{r}
cat("# The code creates two generic funtions, g() and h(), and methods for each generic.
# One method of g() is created for numeric objects,
# and two medhos of f() are created for character and numeric objects.\n\n")

y <- 1
g <- function(x) {
  y <- 2
  UseMethod("g")
}
g.numeric <- function(x) y
g(10)

h <- function(x) {
  x <- 10
  UseMethod("h")
}
h.character <- function(x) paste("char", x)
h.numeric <- function(x) paste("num", x)

h("a")
h(2)
tryCatch(h(TRUE), error = function(e) e)
```

6. Internal generics don't dispatch on the implicit class of base types. Carefully read ?"internal generic" to determine why the length of f and g is different in the example below. What function helps distinguish between the behaviour of f and g?

f <- function() 1
g <- function() 2
class(g) <- "function"

class(f)
class(g)

length.function <- function(x) "function"
length(f)
length(g)

```{r}
cat("# The class of f is implicit while the class of g is explicitly assigned.
# Therefore, althought both f and g have the class of funciton,
# passing f to length(), a primitive generic function, 
# would not dispatch a method, but passing g to length() would dispatch length.function()\n\n") 

f <- function() 1
g <- function() 2
class(g) <- "function"

class(f)
class(g)

length.function <- function(x) "function"
length(f)
length(g)
```

```{r}
ftype(length)
```

## S4

Notes:

You can get a list of all S4 generics with getGenerics(), and a list of all S4 classes with getClasses(). This list includes shim classes for S3 classes and base types. You can list all S4 methods with showMethods(), optionally restricting selection either by generic or by class (or both). It's also a good idea to supply where = search() to restrict the search to methods available in the global environment.

Additional Materials: 
https://www.cyclismo.org/tutorial/R/s4Classes.html
https://www.coursera.org/learn/bioconductor/lecture/N1xBf/r-s4-classes

```{r}
library(stats4)
library(methods)
# getGenerics()
# getClasses()

# get help for function
help(mle)

# Get help for S4 class
class?mle
```

1. Which S4 generic has the most methods defined for it? Which S4 class has the most methods associated with it?

```{r}
# All S4 related code is stored in the methods package.
methods_objs <- mget(ls("package:methods"), inherits = TRUE)
is_S4 <- sapply(methods_objs, isS4)
S4_generics <- methods_objs[is_S4]
S4_methods_list <- lapply(names(S4_generics), .S4methods)
most_S4_methods <- 
  S4_generics[sapply(S4_methods_list, length) == 
                max(sapply(S4_methods_list, length))]

cat("S4 generic with most methods: \n")
names(most_S4_methods)
cat("\nNumber of methods: \n")
length(methods(names(most_S4_methods)))
```

The below chunk of code uses this webpage as reference: (https://bookdown.org/Tazinho/Advanced-R-Solutions/oo-field-guide.html) 

```{r}
all_classes <- getClasses(inherits = TRUE)
class <- all_classes[1]

countMethods <- function(class){
  methods <- showMethods(classes = class, printTo = FALSE)
  sum(grepl("Function", methods))
}

all_Methods_count <- sapply(all_classes, countMethods)
S4Class_most_Method <- all_classes[all_Methods_count == max(all_Methods_count)]
message("S4 class has the most methods: ", S4Class_most_Method,
        "\nNumber of methods: ", countMethods(S4Class_most_Method))
```

2. What happens if you define a new S4 class that doesn't "contain" an existing class? (Hint: read about virtual classes in ?setClass.)

```{r, echo=FALSE}
message(
  "A virtual class would be created when the contain argument is not supplied. No actual objects can be created from the virtual classes. A virtual class may include slots to provide some common behavior without fully defining the object. Note that 'VIRTUAL' does not carry over to subclasses; a class that contains a virtual class is not itself automatically virtual."
)
```

3. What happens if you pass an S4 object to an S3 generic? What happens if you pass an S3 object to an S4 generic? (Hint: read ?setOldClass for the second case.)



```{r}
message(
  "S4 classes can be used for any S3 method selection; when an S4 object is detected, S3 method selection uses the contents of extends(class(x)) as the equivalent of the S3 inheritance (the inheritance is cached after the first call). An existing S3 method may not behave as desired for an S4 subclass, in which case utilities such as asS3 and S3Part may be useful. If the S3 method fails on the S4 object, asS3(x) may be passed instead; if the object returned by the S3 method needs to be incorporated in the S4 object, the replacement function for S3Part may be useful, as in the method for class 'myFrame' in the examples.
  
S3 classes can be used for any S4 method selection, provided that the S3 classes have been registered by a call to setOldClass, with that call specifying the correct S3 inheritance pattern. A call to setOldClass creates formal classes corresponding to S3 classes, allows these to be used as slots in other classes or in a signature in setMethod, and mimics the S3 inheritance. 

Reference: 
https://www.rdocumentation.org/packages/methods/versions/3.3.1/topics/Methods
https://www.rdocumentation.org/packages/methods/versions/3.3.1/topics/setOldClass"
)
```

## RC

## Picking a system