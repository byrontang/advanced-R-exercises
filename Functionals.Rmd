---
title: "Functionals"
author: "Byron Tang"
date: "July 16, 2018"
output: html_document
---

```{r setup, include=FALSE}
library(parallel)
```

## My first functional: lapply()

1. Why are the following two invocations of lapply() equivalent?

trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(100)

lapply(trims, function(trim) mean(x, trim = trim))
lapply(trims, mean, x = x)

```{r, echo=FALSE}
message("In both invocations, the trim argument in mean is supplied by each element in trims while the x argument is constantly the x vector. Therefore, the outputs are the same.")
```

2. The function below scales a vector so it falls in the range [0, 1]. How would you apply it to every column of a data frame? How would you apply it to every numeric column in a data frame?

scale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

```{r}
scale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

# Apply the function to every column of a data frame
df_num <- data.frame(lapply(mtcars, scale01))
head(df_num)

# Apply to every numeric column in a data frame
mtcars2 <- mtcars
mtcars2$vs <- factor(mtcars2$vs)
mtcars2$am <- factor(mtcars2$am)
df_num2 <- data.frame(lapply(mtcars2[sapply(mtcars2, is.numeric)], scale01))
head(df_num2)
```

3. Use both for loops and lapply() to fit linear models to the mtcars using the formulas stored in this list:

formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)

```{r}
formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)
# For loop
list_lm <- vector("list", length(formulas))
for (i in 1:length(formulas)){
  list_lm[[i]] <- lm(formulas[[i]], data = mtcars)
}
lapply(list_lm, function(x) round(x$coefficients, 5))

# lapply
list_lm2 <- lapply(formulas, function(x) lm(x, data = mtcars))
lapply(list_lm2, function(x) round(x$coefficients, 5))
```

4. Fit the model mpg ~ disp to each of the bootstrap replicates of mtcars in the list below by using a for loop and lapply(). Can you do it without an anonymous function?

bootstraps <- lapply(1:10, function(i) {
  rows <- sample(1:nrow(mtcars), rep = TRUE)
  mtcars[rows, ]
})

```{r}
# For loop
list_lm3 <- vector("list", 10)
for(i in 1:10){
  rows <- sample(1:nrow(mtcars), rep = TRUE)
  list_lm3[[i]] <- lm(mpg ~ disp, mtcars[rows, ])
}
sapply(list_lm3, function(x) round(x$coefficients, 5))

# Combine all steps into one lapply() function.
# However, it's unavoidable to use an anonymous function
# Note: Need to set simplify as FALSE to keep data frame format from replicate()
list_lm4 <- lapply(replicate(10, mtcars[sample(1:nrow(mtcars), rep = TRUE), ],
                             simplify = FALSE), 
                   function(x) lm(mpg ~ disp, data = x))
sapply(list_lm4, function(x) round(x$coefficients, 5))
```

5. For each model in the previous two exercises, extract R2 using the function below.

rsq <- function(mod) summary(mod)$r.squared

```{r}
rsq <- function(mod) summary(mod)$r.squared
sapply(list_lm, rsq)
sapply(list_lm2, rsq)
sapply(list_lm3, rsq)
sapply(list_lm4, rsq)
```

## For loop funcitonals: friends of lapply()

1. Use vapply() to:
a. Compute the standard deviation of every column in a numeric data frame.
b. Compute the standard deviation of every numeric column in a mixed data frame. (Hint: you'll need to use vapply() twice.)

```{r}
# a
vapply(mtcars, sd, numeric(1))
# b
vapply(mtcars[, vapply(mtcars2, is.numeric, logical(1))], sd, numeric(1))
```

2. Why is using sapply() to get the class() of each element in a data frame dangerous?

```{r, echo=FALSE}
message("The elements in a data frame might not have only one class. When any one of the element has more than one class, sapply would return a list instead of a vector. It might error out thefollowing process or function without clear message if the expected output is a vector.")
```

3. The following code simulates the performance of a t-test for non-normal data. Use sapply() and an anonymous function to extract the p-value from every trial.

trials <- replicate(
  100, 
  t.test(rpois(10, 10), rpois(7, 10)),
  simplify = FALSE
)
Extra challenge: get rid of the anonymous function by using [[ directly.

```{r}
trials <- replicate(
  100, 
  t.test(rpois(10, 10), rpois(7, 10)),
  simplify = FALSE
)
head(sapply(trials, function(x) x$p.value), 10)
head(unlist(Map(`[[`, trials, "p.value")), 10)
```

4. What does replicate() do? What sort of for loop does it eliminate? Why do its arguments differ from lapply() and friends?

```{r}
message("replicate is a wrapper for the common use of sapply for repeated evaluation of an expression (which will usually involve random number generation).
        
It eliminates the loop over the numeric indices: for (i in n)

Only replicate has the argument of expr, which is the expression (a language object, usually a call) to evaluate repeatedly.")

```

5. Implement a version of lapply() that supplies FUN with both the name and the value of each component.

```{r}
# Create function
lapply2 <- function(x1, x2, FUN, ...){
  out <- vector("list", length(x1))
  for (i in seq_along(x1)) {
    out[[i]] <- weighted.mean(x1[[i]], x2[[i]])
  }
  out
}
xs <- replicate(5, runif(10), simplify = FALSE)
ws <- replicate(5, rpois(10, 5) + 1, simplify = FALSE)

# Test and check with Map()
unlist(lapply2(xs, ws, weighted.mean))
unlist(Map(weighted.mean, xs, ws))
```

6. Implement a combination of Map() and vapply() to create an lapply() variant that iterates in parallel over all of its inputs and stores its outputs in a vector (or a matrix). What arguments should the function take?

```{r}
# Create the function
lapply3 <- function (f, mc.cores = 1L, FUN.VALUE = character(1), ...) 
{
	cores <- as.integer(mc.cores)
	if (cores < 1L) 
		stop("'mc.cores' must be >= 1")
	if (cores > 1L) 
		stop("'mc.cores' > 1 is not supported on Windows")
	vapply(Map(f, ...), function(x) x, FUN.VALUE = FUN.VALUE)
}

# Test (mc.core must be exactly 1 on Windows (which uses the master process))
lapply3(xs, ws, f = weighted.mean, mc.cores = 1L, FUN.VALUE = numeric(1))
```

7. Implement mcsapply(), a multicore version of sapply(). Can you implement mcvapply(), a parallel version of vapply()? Why or why not?

```{r}
# Create function mcsapply
mcsapply <- function (X, FUN, ..., mc.preschedule = TRUE, mc.set.seed = TRUE, 
	mc.silent = FALSE, mc.cores = 1L, mc.cleanup = TRUE, mc.allow.recursive = TRUE, 
	affinity.list = NULL) 
{
	cores <- as.integer(mc.cores)
	if (cores < 1L) 
		stop("'mc.cores' must be >= 1")
	if (cores > 1L) 
		stop("'mc.cores' > 1 is not supported on Windows")
	sapply(X, FUN, ...)
}

# Test
mcsapply(mtcars, mean)
```
```{r}
# Technically we could also create mcvapply
# However, my test case is limited to windows.
mcvapply <- function (X, FUN, ..., mc.preschedule = TRUE, mc.set.seed = TRUE, 
	mc.silent = FALSE, mc.cores = 1L, mc.cleanup = TRUE, mc.allow.recursive = TRUE, 
	affinity.list = NULL) 
{
	cores <- as.integer(mc.cores)
	if (cores < 1L) 
		stop("'mc.cores' must be >= 1")
	if (cores > 1L) 
		stop("'mc.cores' > 1 is not supported on Windows")
	vapply(X, FUN, ...)
}

mcvapply(mtcars, class, character(1))
```

## Manipulating matrices and data frames

1. How does apply() arrange the output? Read the documentation and perform some experiments.

```{r, echo=FALSE}
message("If each call to FUN returns a vector of length n, then apply returns an array of dimension c(n, dim(X)[MARGIN]) if n > 1. If n equals 1, apply returns a vector if MARGIN has length 1 and an array of dimension dim(X)[MARGIN] otherwise. If n is 0, the result has length 0 but not necessarily the 'correct' dimension.

If the calls to FUN return vectors of different lengths, apply returns a list of length prod(dim(X)[MARGIN]) with dim set to MARGIN if this has length greater than one.")
```

```{r}
# When n > 1, return an array of dimension c(n, dim(X)[MARGIN])
dim(apply(mtcars, 2, function(x) c(mean(x), median(x))))

# When n = 1, return a vector (no dimension)
dim(apply(mtcars, 2, mean))

# When n = 0, the result has length 0
length(apply(mtcars, 2, function(x) NULL))

# When returning vectors of different lengths 
# (example from R documentation)
z <- array(1:24, dim = 2:4)
zseq <- apply(z, 1:2, function(x) seq_len(max(x)))
apply(z, 3, function(x) seq_len(max(x)))
```

2. There's no equivalent to split() + vapply(). Should there be? When would it be useful? Implement one yourself.

```{r, warning=FALSE}
message("There should be a equivalent function of split() + vapply() as it could be useful when this kind of function needs to always generate desirable outputs in cases such as implemention in another function.\n")

# tapply throughs an error when one of the output has lenght zero
pulse <- c(round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12)), NULL)
group <- c(rep(c("A", "B"), c(10, 12)), "C")
try(tapply(pulse, group, length))

# Implement split() + vapply() (warning is muted)
tapply2 <- function(x, group, f, FUN.VALUE, ...) {
  pieces <- split(x, group)
  vapply(pieces, f, FUN.VALUE)
}
tapply2(pulse, group, length, numeric(1))
```

3. Implement a pure R version of split(). (Hint: use unique() and subsetting.) Can you do it without a for loop?

```{r}
# Create the function
split2 <- function(x, group){
  g <- unique(group)
  out <- lapply(g, function(g) x[group == g])
  setNames(out, g)
}

# Test
pulse <- c(round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12)))
group <- c(rep(c("A", "B"), c(10, 12)))
split2(pulse, group)
```

4. What other types of input and output are missing? Brainstorm before you look up some answers in the plyr paper.

Reference:
The Split-Apply-Combine Strategy for Data Analysis (https://www.jstatsoft.org/article/view/v040i01)

```{r}
message("Output: Discarded (*_ply)

Sometimes it is convenient to operate on a list purely for the side eects, e.g., plots, caching,
and output to screen/le. In this case *_ply is a little more ecient than abandoning the
output of *lply because it does not store the intermediate results.
The *_ply functions have one additional argument, .print, which controls whether or not
each result should be printed. This is useful when working with lattice (Sarkar 2008) or
ggplot2 (Wickham 2010) graphics.")

```

## Manipulating lists

1. Why isn't is.na() a predicate function? What base R function is closest to being a predicate version of is.na()?

```{r}
message("is.na() doesn't return a single TRUE or FALSE")
list_test <-
  list(a = c(1:5),
       b = replicate(5, NA))
message("To return a single TRUE or FALSE, one option is to combine all() and is.na() from base R functions.")
sapply(list_test, function(x) all(is.na(x)))
```

2. Use Filter() and vapply() to create a function that applies a summary statistic to every numeric column in a data frame.

```{r}
# Create new funciton
summary2 <- function(df){
  vapply(Filter(is.numeric, df), summary, FUN.VALUE = numeric(6))
}

# Test (vs and am are factors)
summary2(mtcars2)
```

3. What's the relationship between which() and Position()? What's the relationship between where() and Filter()?

```{r}
message("Position() is equivalent to:

  function(x) which(x)[1]

which() returns the opsition of all the lements that match the predicate, while Position() returns the position of the first element that matches the predicate (or the last element if right = TRUE).
        
Filter() could be considered as: 

  function(f, x) x[where(f, x)]

where() returns a logical vector of TRUE and FALSE indicating whether the element matchs the preicate , but Filter() selects those elements which match the predicate.")
```

4. Implement Any(), a function that takes a list and a predicate function, and returns TRUE if the predicate function returns TRUE for any of the inputs. Implement All() similarly.

```{r}
Any <- function(f, x){
  any(where(f, x))
}
All <- function(f, x){
  all(where(f, x))
}

Any(is.numeric, mtcars2)
All(is.numeric, mtcars2)
All(is.numeric, mtcars)
```

5. Implement the span() function from Haskell: given a list x and a predicate function f, span returns the location of the longest sequential run of elements where the predicate is true. (Hint: you might find rle() helpful.)

```{r}
# Create the function
span <- function(f, x){
  y <- unname(vapply(x, f, logical(1)))
  sq <- rle(y)
  lengthsTrue <- sq$lengths[sq$values]
  positions <- cumsum(sq$lengths)
  positionsTrue <- positions[sq$values]
  longest_seq <- max(lengthsTrue)
  longest_position <- Position(function(x) x == longest_seq, lengthsTrue)
  # senario 1
  if (longest_position == 1 & sq$values[1]){
    starting <- 1
  # senario 2
  } else if (longest_position == 1 & !sq$values[1]) {
    starting <- positionsTrue[1] - 1
  # senario 3
  } else {
    starting <- positionsTrue[longest_position - 1] + 1
  }
  return(seq(starting, starting + longest_seq - 1))
}

# Test
vapply(mtcars2, is.factor, logical(1))
span(is.numeric, mtcars2) # senario 1
span(is.factor, mtcars2) # senario 2
span(is.numeric, mtcars2[c("qsec", "vs", "am", "gear", "carb")]) # senario 3
```

## Mathematical functionals

## Loops that shouldn be left as is

## A family of functions