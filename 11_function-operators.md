Function Operators
================
Byron Tang
July 30, 2018

Behavioural FOs
---------------

#### 1. Write a FO that logs a time stamp and message to a file every time a function is run.

Create function

``` r
logTime <- function(fileName, f) {
  function(...){
    write(Sys.time(), file = fileName, append=TRUE)
    f(...)
  }
}
```

Test function

``` r
logTime("c:/Users/byron/Desktop/FO_ex1.txt", rnorm)(1)
```

    ## [1] 1.119812

1.  What does the following function do? What would be a good name for it?

``` r
f <- function(g) {
  force(g)
  result <- NULL
  function(...) {
    if (is.null(result)) {
      result <<- g(...)
    }
    result
  }
}
runif2 <- f(runif)
runif2(5)
   [1] 0.3856219 0.2596573 0.3964255 0.5439418 0.3688169
runif2(10)
   [1] 0.3856219 0.2596573 0.3964255 0.5439418 0.3688169
```

The function remembers the result when the input function is run at the first time so that everytime it runs the result of the first time is returned. A name that indicates this feature would be good.

#### 3. Modify delay\_by() so that instead of delaying by a fixed amount of time, it ensures that a certain amount of time has elapsed since the function was last called. That is, if you called g &lt;- delay\_by(1, f); g(); Sys.sleep(2); g() there shouldn't be an extra delay.

Modify funtion

``` r
delay_by <- function(delay, f) {
  force(f)
  lastTime <- NULL
  function(...) {
    if (is.null(lastTime)) {
      Sys.sleep(delay)
    } else if (Sys.time() - delay < lastTime) {
      delayed <- Sys.time() - lastTime
      Sys.sleep(delay - delayed)
    }
    f(...)
    lastTime <<- Sys.time()
    lastTime
  }
}
```

Test function

``` r
g1 <- delay_by(3, rnorm)
g1(1) # Start time
```

    ## [1] "2018-08-11 09:43:36 CDT"

``` r
Sys.sleep(5)
g1(1) # No elapse
```

    ## [1] "2018-08-11 09:43:41 CDT"

``` r
Sys.sleep(2)
g1(1) # Elapse for 1 sec
```

    ## [1] "2018-08-11 09:43:44 CDT"

``` r
g1(1) # Elapse for 3 sec
```

    ## [1] "2018-08-11 09:43:47 CDT"

#### 4. Write wait\_until() which delays execution until a specific time.

Create function

``` r
wait_until <- function(t, f){
  i <- 0
  function(...){
    while(Sys.time() < t){
      Sys.sleep(1)
      i <<- i + 1
      if (i %% 10 == 0) cat(".")
    }
    f(...)
  }
}
```

Test function

``` r
wait_until(Sys.time() + 30, rnorm)(1)
```

    ## ...

    ## [1] 2.327258

#### 5. There are three places we could have added a memoise call: why did we choose the one we did?

``` r
download <- memoise(dot_every(10, delay_by(1, download_file)))
download <- dot_every(10, memoise(delay_by(1, download_file)))
download <- dot_every(10, delay_by(1, memoise(download_file)))
```

The first option caches the the whole process that runs all the files. If there are duplicates, they will still be processed.

The last option could avoid the process time of the same file, but it will still be delayed for 1 second no matter the file has been cached or not.

In contrary, the second option could skip the process time of the same file and the delayed time to directly return the result. Therefore, the second option is optimal.

#### 6. Why is the remember() function inefficient? How could you implement it in more efficient way?

``` r
remember <- function() {
  memory <- list()
  f <- function(...) {
    # This is inefficient!
    memory <<- append(memory, list(...))
    invisible()
  }

  structure(f, class = "remember")
}
```

The problem in this code is that memory keeps on growing and growing. The operating system needs to allocate more and more space as the object grows. This process is really slow.

Reference and more efficient alternatives:

<https://stat.ethz.ch/pipermail/r-help/2011-August/287303.html>

#### 7. Why does the following code, from stackoverflow, not do what you expect?

``` r
# return a linear function with slope a and intercept b.
f <- function(a, b) function(x) a * x + b

# create a list of functions with different parameters.
fs <- Map(f, a = c(0, 1), b = c(0, 1))

fs[[1]](3)
   [1] 0
# should return 0 * 3 + 0 = 0
```

#### How can you modify f so that it works correctly?

The original function only returns the result. To print out the whole equation, we need to use cat and do some formatting.

``` r
f <- function(a, b) function(x) cat(a, "*", x, "+", b, "=", a * x + b)
fs <- Map(f, a = c(0, 1), b = c(0, 1))
fs[[1]](3)
```

    ## 0 * 3 + 0 = 0

Output FOs
----------

#### 1. Create a negative() FO that flips the sign of the output of the function to which it is applied.

Create function

``` r
negative <- function(f){
  force(f)
  function(...) f(...) * -1
}
```

Test function

``` r
negative(mean)(1:5)
```

    ## [1] -3

#### 2. The evaluate package makes it easy to capture all the outputs (results, text, messages, warnings, errors, and plots) from an expression. Create a function like capture\_it() that also captures the warnings and errors generated by a function.

Create function

``` r
evaluate_it <- function(f) {
  force(f)
  function(...) {
    evaluate(try(f(...)))
  }
}
```

Test function

``` r
x1 <- evaluate_it(log)(11)
x2 <- evaluate_it(log)(-1)
```

    ## Warning in f(...): NaNs produced

``` r
x3 <- evaluate_it(log)("a")

x1[[2]]
```

    ## [1] "[1] 2.397895\n"

``` r
x2[[2]]
```

    ## [1] "[1] NaN\n"

``` r
x3[[2]]
```

    ## <simpleError in f(...): non-numeric argument to mathematical function>

#### 3. Create a FO that tracks files created or deleted in the working directory (Hint: use dir() and setdiff().) What other global effects of functions might you want to track?

Create function - a simple prototype that does not consider create/delete multiple files

``` r
track_files <- function(f, wd){
  function(...) {
    suppressWarnings(setwd(wd))
    files <- dir()
    f(...)
    new_files <- dir()
    if (length(files) < length(new_files)) 
      cat("File added:", setdiff(new_files, files), "\n")
      # Additional effect is to track if the file has been created before.
    if (length(files) == length(new_files)) 
      warning("\nFile already exists.\n")
    if (length(new_files) < length(files)) 
      cat("File deleted:", setdiff(files, new_files), "\n")
  }
}
```

Test function

``` r
track_files(write, "C:/Users/byron/Desktop")(Sys.time(), "test.txt")
```

    ## File added: test.txt

``` r
track_files(write, "C:/Users/byron/Desktop")(Sys.time(), "test.txt")
```

    ## Warning in track_files(write, "C:/Users/byron/Desktop")(Sys.time(), "test.txt"): 
    ## File already exists.

``` r
track_files(file.remove, "C:/Users/byron/Desktop")("test.txt")
```

    ## File deleted: test.txt

Input FOs
---------

#### 1. Our previous download() function only downloads a single file. How can you use partial() and lapply() to create a function that downloads multiple files at once? What are the pros and cons of using partial() vs. writing a function by hand?

Previous functions

``` r
download_file <- function(url, ...) {
  download.file(url, basename(url), ...)
}

delay_by <- function(delay, f) {
  function(...) {
    Sys.sleep(delay)
    f(...)
  }
}

dot_every <- function(n, f) {
  i <- 1
  function(...) {
    if (i %% n == 0) cat(".")
    i <<- i + 1
    f(...)
  }
}

download <- dot_every(10, memoise(delay_by(1, download_file)))
```

Create new function

``` r
download_files <- partial(lapply, FUN = download)
```

Pros: Very concise and clear codes when the download function has been created.

Cons: Need to create download and other functions it uses first.

#### 2. Read the source code for plyr::colwise(). How does the code work? What are colwise()'s three main tasks? How could you make colwise() simpler by implementing each task as a function operator? (Hint: think about partial().)

In short, colwise uses do.call and lapply inside the source code to make a function that operates on a vector operate on a data.frame.

Three main taskes: 1. Filter column by function passed into .cols argument (ex: is.numeric) 2. Keep all columns if no function is passed into .cols argument 3. Apply function on data.frame

implementing each task by partial() with a simplified function

``` r
colwise2 <- function (.fun, .cols = true) 
{
    if (!is.function(.cols)) {
        .cols <- as.quoted(.cols)
        # filter <- function(df) eval.quoted(.cols, df)
        filter <- partial(eval.quoted, exprs = .cols)
    }
    else {
        # filter <- function(df) Filter(.cols, df)
        filter <- partial(Filter, f = .cols)
    }
    function(df) {
        stopifnot(is.data.frame(df))
        df <- strip_splits(df)
        filtered <- filter(df)
        if (length(filtered) == 0) 
            return(data.frame())
        # out <- do.call("lapply", c(list(filtered, .fun, ...), dots))
        f2 <- partial(lapply, FUN = .fun)
        out <- f2(filtered)
        names(out) <- names(filtered)
        quickdf(out)
    }
}
```

Test function

``` r
nmissing <- function(x) sum(is.na(x))
colwise(nmissing)(mtcars)
```

    ##   mpg cyl disp hp drat wt qsec vs am gear carb
    ## 1   0   0    0  0    0  0    0  0  0    0    0

``` r
colwise2(nmissing)(mtcars)
```

    ##   mpg cyl disp hp drat wt qsec vs am gear carb
    ## 1   0   0    0  0    0  0    0  0  0    0    0

#### 3. Write FOs that convert a function to return a matrix instead of a data frame, or a data frame instead of a matrix. If you understand S3, call them as.data.frame.function() and as.matrix.function().

Create function as.data.frame.funciton

``` r
as.data.frame.function <- function(f){
  force(f)
  function(...)  as.data.frame(f(...))
}
```

Test function

``` r
as.data.frame.function(matrix)(1:20, nrow = 4)
```

    ##   V1 V2 V3 V4 V5
    ## 1  1  5  9 13 17
    ## 2  2  6 10 14 18
    ## 3  3  7 11 15 19
    ## 4  4  8 12 16 20

Create function as.matrix.funciton

``` r
as.matrix.function <- function(f){
  force(f)
  function(...)  as.matrix(f(...))
}
```

Test function

``` r
as.matrix.function(data.frame)(a = c(1:3), b = letters[1:3])
```

    ##      a   b  
    ## [1,] "1" "a"
    ## [2,] "2" "b"
    ## [3,] "3" "c"

#### 4. You've seen five functions that modify a function to change its output from one form to another. What are they? Draw a table of the various combinations of types of outputs: what should go in the rows and what should go in the columns? What function operators might you want to write to fill in the missing cells? Come up with example use cases.

1.  Negate
2.  failwith
3.  capture\_it
4.  time\_it 5, evaluate\_it

Combinations of types of outputs

|              | Other values | String       |
|--------------|--------------|--------------|
| Boolean      | Negate       |              |
| NULL         | failwith     |              |
| Errors       |              | capture\_it  |
| Process Time |              | time\_it     |
| Warnings     |              | evaluate\_it |

Other function operators to fill in:

1.  return\_error(): Return TRUE if there's an error so that we could quickly filter the input that generates an error.
2.  return\_warning(): Return TRUE if there's a warning message so that we could go back and check input that produces a warning

Combinations of types of outputs

|              | Other values    | String       |
|--------------|-----------------|--------------|
| Boolean      | Negate          |              |
| NULL         | failwith        |              |
| Errors       | return\_error   | capture\_it  |
| Process Time |                 | time\_it     |
| Warnings     | return\_warning | evaluate\_it |

#### 5. Look at all the examples of using an anonymous function to partially apply a function in this and the previous chapter. Replace the anonymous function with partial(). What do you think of the result? Is it easier or harder to read?

Example 1

``` r
randomise <- function(f) f(runif(1e3))
randomise(mean)
```

    ## [1] 0.4966723

``` r
# use partial()
randomise_p <- partial(runif, 1e3)
mean(randomise_p())
```

    ## [1] 0.4945343

Example 2

``` r
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)
unlist(lapply(trims, function(trim) mean(x, trim = trim)))
```

    ## [1] -1.05990930 -0.04009117 -0.04473234 -0.03702786

``` r
# use partial()
unlist(lapply(trims, partial(mean, x = x)))
```

    ## [1] -1.05990930 -0.04009117 -0.04473234 -0.03702786

Example 3

``` r
xs <- replicate(5, runif(10), simplify = FALSE)
ws <- replicate(5, rpois(10, 5) + 1, simplify = FALSE)
unlist(Map(function(x, w) weighted.mean(x, w, na.rm = TRUE), xs, ws))
```

    ## [1] 0.3945983 0.5546088 0.4229866 0.4200183 0.3455620

``` r
# use partial
unlist(Map(partial(weighted.mean, na.rm = TRUE), xs, ws))
```

    ## [1] 0.3945983 0.5546088 0.4229866 0.4200183 0.3455620

Example 4

``` r
where <- function(f, x) {
  vapply(x, f, logical(1))
}
df <- data.frame(x = 1:3, y = c("a", "b", "c"))
where(is.factor, df)
```

    ##     x     y 
    ## FALSE  TRUE

``` r
# use partial
partial(vapply, FUN.VALUE = logical(1))(df, is.factor)
```

    ##     x     y 
    ## FALSE  TRUE

Example 5

``` r
slow_function <- function() {
  Sys.sleep(1)
  10
}
system.time(slow_function())
```

    ##    user  system elapsed 
    ##       0       0       1

``` r
# use partial()
system.time(partial(Sys.sleep, 1)(), 10)
```

    ##    user  system elapsed 
    ##       0       0       1

Example 6

``` r
splat <- function (f) {
  force(f)
  function(args) {
    do.call(f, args)
  }
}
x <- c(NA, runif(100), 1000)
args <- list(
  list(x),
  list(x, na.rm = TRUE),
  list(x, na.rm = TRUE, trim = 0.1)
)
lapply(args, splat(mean))
```

    ## [[1]]
    ## [1] NA
    ## 
    ## [[2]]
    ## [1] 10.4259
    ## 
    ## [[3]]
    ## [1] 0.5384837

``` r
# use partial()
splat2 <- function(f) {
  force(f)
  partial(do.call, what = f)
}

lapply(args, splat2(mean))
```

    ## [[1]]
    ## [1] NA
    ## 
    ## [[2]]
    ## [1] 10.4259
    ## 
    ## [[3]]
    ## [1] 0.5384837

Combining FOs
-------------

#### 1. Implement your own version of compose() using Reduce and %o%. For bonus points, do it without calling function.

Create function

``` r
`%o%` <- function(f, g){
  Funcall <- function(f, ...) f(...)
  function(x){
    Reduce(Funcall, list(f,g), x, right = TRUE)
  }
}
```

Test function

``` r
# compose
sapply(mtcars, compose(length, unique))
```

    ##  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
    ##   25    3   27   22   22   29   30    2    2    3    6

``` r
# new function
sapply(mtcars, length %o% unique)
```

    ##  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
    ##   25    3   27   22   22   29   30    2    2    3    6

``` r
# without calling a function
sapply(mtcars, function(x) length(unique(x)))
```

    ##  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb 
    ##   25    3   27   22   22   29   30    2    2    3    6

#### 2. Extend and() and or() to deal with any number of input functions. Can you do it with Reduce()? Can you keep them lazy (e.g., for and(), the function returns once it sees the first FALSE)?

and() and or()

``` r
and <- function(f1, f2) {
  force(f1); force(f2)
  function(...) {
    f1(...) && f2(...)
  }
}

or <- function(f1, f2) {
  force(f1); force(f2)
  function(...) {
    f1(...) || f2(...)
  }
}
```

Extend and() and or() by using Reduce Note: stuck on create a new function.

``` r
try(Filter(and, list(is.character, is.factor, is.numeric), iris))
Filter(Reduce(and, list(is.character, is.factor, is.numeric)), iris)
```

    ## data frame with 0 columns and 150 rows

``` r
head(Filter(Reduce(or, list(is.character, is.factor, is.numeric)), iris))
```

    ##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
    ## 1          5.1         3.5          1.4         0.2  setosa
    ## 2          4.9         3.0          1.4         0.2  setosa
    ## 3          4.7         3.2          1.3         0.2  setosa
    ## 4          4.6         3.1          1.5         0.2  setosa
    ## 5          5.0         3.6          1.4         0.2  setosa
    ## 6          5.4         3.9          1.7         0.4  setosa

#### 3. Implement the xor() binary operator. Implement it using the existing xor() function. Implement it as a combination of and() and or(). What are the advantages and disadvantages of each approach? Also think about what you'll call the resulting function to avoid a clash with the existing xor() function, and how you might change the names of and(), not(), and or() to keep them consistent.

Create function using the existing xor() function

``` r
xorFO1 <- function(f1, f2){
  force(f1); force(f2)
  function(...) {
    xor(f1(...), f2(...))
  }
}
```

Create function using the and() and or()

``` r
xorFO2 <- function(f1, f2){
  force(f1); force(f2)
  function(...) {
    sapply(..., or(f1, f2)) & !sapply(..., and(f1, f2))
  }
}
```

Test functions

``` r
head(Filter(and(is.numeric, is.double), iris))
```

    ##   Sepal.Length Sepal.Width Petal.Length Petal.Width
    ## 1          5.1         3.5          1.4         0.2
    ## 2          4.9         3.0          1.4         0.2
    ## 3          4.7         3.2          1.3         0.2
    ## 4          4.6         3.1          1.5         0.2
    ## 5          5.0         3.6          1.4         0.2
    ## 6          5.4         3.9          1.7         0.4

``` r
Filter(xorFO1(is.numeric, is.double), iris)
```

    ## data frame with 0 columns and 150 rows

``` r
iris[xorFO2(is.numeric, is.double)(iris)]
```

    ## data frame with 0 columns and 150 rows

The advantage to implement xorFO() with existing xor() function is obviously clear codes and consistent usage with and() and or().

On the other hand, implementing xorFO() with and() and or() has some disadvantages. It requires more code, and the way to use the function is not consistent to and() and or().

To avoide clash, I would rename and() and or() as andFO() and orFO() respectively to signal their feature of functional operation.

#### 4. Above, we implemented boolean algebra for functions that return a logical function. Implement elementary algebra (plus(), minus(), multiply(), divide(), exponentiate(), log()) for functions that return numeric vectors.

Create function - plus

``` r
plus <- function(f1, f2){
  force(f1); force(f2)
  function(...) {
    f1(...) + f2(...)
  }
}
```

Test fnction

``` r
summary(iris)[3:4,]
```

    ##   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   
    ##  Median :5.800   Median :3.000   Median :4.350   Median :1.300  
    ##  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  
    ##        Species  
    ##  virginica :50  
    ## 

``` r
sapply(iris[1:4], plus(mean, median))
```

    ## Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
    ##    11.643333     6.057333     8.108000     2.499333

The same logc of creating plus could be applied to create minus, multiply, divide, and exponentiate by simply replace `+` with `-`, `*`, `/`, and `^`

Create function - log

``` r
log_new <- function(f1, f2){
  force(f1); force(f2)
  function(...) {
    out1 <- sapply(..., f1)
    out2 <- sapply(..., f2)
    stopifnot(length(out1) == length(out2))
    len <- length(out1)
    l <- vector(mode = "double", length = len)
    for (i in c(1:len)) {
      l[i] <- log(out1[i], base = out2[i])
    }
    names(l) <- names(out1)
    return(l)
  }
}
```

Test function

``` r
log_new(mean, median)(iris[1:4])
```

    ## Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
    ##    1.0042344    1.0172315    0.9004956    0.6927996
