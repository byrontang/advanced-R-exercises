---
title: "Subsetting"
author: "Byron Tang"
date: "May 14, 2018"
output: html_document
---

```{r setup}
mtcars
```

## Data Type

1. Fix each of the following common data frame subsetting errors:

mtcars[mtcars$cyl = 4, ]

mtcars[-1:4, ]

mtcars[mtcars$cyl <= 5]

mtcars[mtcars$cyl == 4 | 6, ]

```{r}
mtcars[mtcars$cyl == 4,]
mtcars[1:4, ]
mtcars[mtcars$cyl <= 5,]
mtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]
```

2. Why does x <- 1:5; x[NA] yield five missing values? (Hint: why is it different from x[NA_real_]?)

```{r}
# NA is a logical vector of lenght 1. When the logical vector is shorter than the vector being subsetted, it will be recycled to be the same length. On the other hand, NA_real_ is a double datatype, so it is not recycled and only retrieves one value.
x <- 1:5
x[NA]
x[NA_real_]
x[as.logical(NA_real_)]
```


3. What does upper.tri() return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?

x <- outer(1:5, 1:5, FUN = "*")

x[upper.tri(x)]

```{r}
x <- outer(1:5, 1:5, FUN = "*")
x
x[upper.tri(x)] # This line returns the upper triangle of matrix x excluding the diagnal
```

4. Why does mtcars[1:20] return an error? How does it differ from the similar mtcars[1:20, ]?

```{r}
class(mtcars)
# mtcars is a data.frame object and not a vector, so we could not use [1:20] to subset it.
# We should use subset it like either a list or a matrix.
# mtcars[1, ] is the way to subset like a matrix
```

5. Implement your own function that extracts the diagonal entries from a matrix (it should behave like diag(x) where x is a matrix).

```{r}
x <- outer(1:5, 1:5, FUN = paste, sep = ",")
x
get_matrix_diagnal <- function(a_matrix){
  if (is.matrix(a_matrix)){
    num <- min(nrow(x), ncol(x))
    diagnal <- cbind(1:num, 1:num)
    return(x[diagnal])
  } else {
    return("Please pass a matrix")
  }
}
cat("\n")
get_matrix_diagnal(x)
get_matrix_diagnal(mtcars)
```

6. What does df[is.na(df)] <- 0 do? How does it work?

```{r}
# The command would assign 0 to all the NA in the df
# Note: need to set stringAsFactors = FALSE, otherwise the command would throw an error.
df <- data.frame(a = c(1, NA, 3),
                 b = c("x", "y", NA),
                 stringsAsFactors = FALSE)
df
df[is.na(df)] <- 0
df
```


## Subsetting Operators

```{r}

```

## SUbsetting and Assignment

## Applications
