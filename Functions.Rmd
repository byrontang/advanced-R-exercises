---
title: "Functions"
author: "Byron Tang"
date: "May 19, 2018"
output: html_document
---

```{r setup}
library(pryr)
```

## Function components

1. What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?

```{r}
is.function(sum)
is.primitive(sum)
is.primitive(summary)
```

2. This code makes a list of all functions in the base package.

objs <- mget(ls("package:base"), inherits = TRUE)
funs <- Filter(is.function, objs)

Use it to answer the following questions:

  a. Which base function has the most arguments?

  b. How many base functions have no arguments? What's special about those functions?

  c. How could you adapt the code to find all primitive functions?

```{r}
objs <- mget(ls("package:base"), inherits = TRUE)
funs <- Filter(is.function, objs) # 1207 functions

# a
funs_arg <- sapply(lapply(names(funs), formals), length)
(most_arg <- names(funs[funs_arg == max(funs_arg)]))
length(formals(most_arg))

# b
no_arg <- funs[funs_arg == 0]
length(no_arg)
no_arg_primitive <- sapply(no_arg, is.primitive)
sum(no_arg_primitive)
## Most of the functions wihtout arguments are primitive

# c
funs_primitive <- Filter(is.primitive, objs) # 183 primitive functions
```

3. What are the three important components of a function?

```{r}
# 1. the body(), the code inside the function.
# 2. the formals(), the list of arguments which controls how you can call the function.
# 3. the environment(), the "map" of the location of the function's variables.
```

4. When does printing a function not show what environment it was created in?

```{r}
# If the environment isn't displayed, it means that the function was created in the global environment.
```

## Lexical Scoping

1. What does the following code return? Why? What does each of the three c's mean?

c <- 10
c(c = c)

```{r}
# It returns a number 10 with a name c. 
# The funciton looks up to find out an object c and get the number that c represents

# The c in c <- 10 represents a number 10
# In c(c = c):
  # First c is a function
  # Second c is name
  # Third c is the c in c <- 10 that represents a number 10

c <- 10
c(c = c)
```

2. What are the four principles that govern how R looks for values?

```{r}
# name masking
# functions vs. variables
# a fresh start
# dynamic lookup
```


3. What does the following function return? Make a prediction before running the code yourself.

f <- function(x) {
  f <- function(x) {
    f <- function(x) {
      x ^ 2
    }
    f(x) + 1
  }
  f(x) * 2
}
f(10)

```{r}
f <- function(x) {
  f <- function(x) {
    f <- function(x) {
      x ^ 2
    }
    f(x) + 1
  }
  f(x) * 2
}
f(10)
```

## Every Opration is a function call

```{r}
x <- NULL
if (!is.null(x) && x > 0) {
  print("test")
}
```

```{r}
add <- function(x) {
  force(x)
  function(y) x + y
}
adders2 <- lapply(1:10, add)
adders2
```



## Function arguments

1. Clarify the following list of odd function calls:

x <- sample(replace = TRUE, 20, x = c(1:10, NA))
y <- runif(min = 0, max = 1, 20)
cor(m = "k", y = y, u = "p", x = x)

```{r}
x <- sample(c(1:10, NA), 20, replace = TRUE)
y <- runif(20, 0, 1)
cor(x, y, use = "pairwise.complete.obs", method = "kendall")
```


2. What does this function return? Why? Which principle does it illustrate?

f1 <- function(x = {y <- 1; 2}, y = 0) {
  x + y
}
f1()

```{r}
# f1 returns 3 because of lazy evaluation:
  # x in x + y is executed first. 
  # When getting x, y is also assigned as 1, 
  # making it unneccessary to execute y = 0
  # Therefore, the output is 2 + 1 = 3
# The code is slightly revised to grab the value of x and y

f1 <- function(x = {y <- 1; 2}, y = 0) {
  print(x) + print(y)
}
f1()
```

```{r}
# To vefity the thought process, change the order of x and y and observe
# The result shows that when y is executed first,
# y = 0 is captured and y <- 0 is ignored.

f2 <- function(x = {y <- 1; 2}, y = 0) {
  print(y) + print(2)
}
f2()
```

3. What does this function return? Why? Which principle does it illustrate?

f2 <- function(x = z) {
  z <- 100
  x
}
f2()

```{r}
# The function returns 100 
# Default arguments are evaluated inside the function;
# The expression depends on the current environment.
  # Even when there is another global variable z exists,
  # x still captures the z inside the function.

z <- 50
f2 <- function(x = z) {
  z <- 100
  x
}
f2()
```

## Sepcial calls

1. Create a list of all the replacement functions found in the base package. Which ones are primitive functions?

```{r}
# objs <- mget(ls("package:base"), inherits = TRUE)
is_replacement <- grepl("<-", names(objs))
sum(is_replacement) # 56 replacement functions
funs_replacement <- objs[is_replacement]
funs_replacement[sapply(funs_replacement, is.primitive)]
```

2. What are valid names for user-created infix functions?

```{r}
# All user-created infix functions must start and end with %
# Ex: %custom%
```

3. Create an infix xor() operator.

```{r}
# Borrow the code from the source code of xor
`%x||%` <- function(x, y) {
  (x | y) & !(x & y)
}

TRUE %x||% TRUE == xor(TRUE, TRUE)
TRUE %x||% FALSE == xor(TRUE, FALSE)
FALSE %x||% FALSE == xor(FALSE, FALSE)
```

4. Create infix versions of the set functions intersect(), union(), and setdiff().

```{r}

```


5. Create a replacement function that modifies a random location in a vector.

## Return values